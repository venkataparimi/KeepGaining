"""
Strategy Engine Foundation

Event-driven strategy execution engine that:
- Subscribes to IndicatorEvent from the event bus
- Evaluates configured strategies against market data
- Generates SignalEvent for potential trades
- Supports hot-reload of strategy configurations
- Maintains strategy state per symbol/timeframe

Architecture:
    IndicatorEvent → StrategyEngine → SignalEvent → PositionManager
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, time, timedelta
from decimal import Decimal
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Type
from zoneinfo import ZoneInfo

from app.core.events import EventBus, EventType, IndicatorEvent, SignalEvent, get_event_bus


class SignalType(str, Enum):
    """Type of trading signal."""
    LONG_ENTRY = "long_entry"
    LONG_EXIT = "long_exit"
    SHORT_ENTRY = "short_entry"
    SHORT_EXIT = "short_exit"


class SignalStrength(str, Enum):
    """Signal confidence level."""
    STRONG = "strong"
    MODERATE = "moderate"
    WEAK = "weak"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    signal_id: str
    strategy_id: str
    strategy_name: str
    symbol: str
    exchange: str
    signal_type: SignalType
    strength: SignalStrength
    entry_price: Decimal
    stop_loss: Decimal
    target_price: Decimal
    quantity_pct: float  # Percentage of capital to allocate
    timeframe: str
    indicators: Dict[str, Any]  # Snapshot of indicators that triggered signal
    reason: str  # Human-readable reason for the signal
    generated_at: datetime
    valid_until: datetime  # Signal expiry time
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyState:
    """Maintains state for a symbol within a strategy."""
    symbol: str
    timeframe: str
    is_in_position: bool = False
    entry_signal_id: Optional[str] = None
    entry_price: Optional[Decimal] = None
    entry_time: Optional[datetime] = None
    last_indicator_update: Optional[datetime] = None
    consecutive_signals: int = 0
    last_signal_type: Optional[SignalType] = None
    custom_state: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Strategies must implement:
    - evaluate(): Analyze indicators and return signal if conditions met
    - get_stop_loss(): Calculate stop loss for a signal
    - get_target(): Calculate target price for a signal
    """
    
    def __init__(
        self,
        strategy_id: str,
        name: str,
        description: str,
        config: Dict[str, Any]
    ):
        self.strategy_id = strategy_id
        self.name = name
        self.description = description
        self.config = config
        self.enabled = True
        self.logger = logging.getLogger(f"{__name__}.{name}")
        
        # Strategy state per symbol
        self._states: Dict[str, StrategyState] = {}
        
        # Trading hours (IST)
        self.market_open = time(9, 15)
        self.market_close = time(15, 30)
        self.no_new_entry_after = time(14, 45)  # Configurable
        
    @abstractmethod
    async def evaluate(
        self,
        symbol: str,
        timeframe: str,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Optional[Signal]:
        """
        Evaluate the strategy conditions and generate signal if criteria met.
        
        Args:
            symbol: Trading symbol (e.g., "NSE:RELIANCE-EQ")
            timeframe: Candle timeframe (e.g., "5m")
            indicators: Dictionary of computed indicators
            candle: Latest candle data
            
        Returns:
            Signal if conditions are met, None otherwise
        """
        pass
    
    @abstractmethod
    def get_stop_loss(
        self,
        entry_price: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Decimal:
        """Calculate stop loss price for the signal."""
        pass
    
    @abstractmethod
    def get_target(
        self,
        entry_price: Decimal,
        stop_loss: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any]
    ) -> Decimal:
        """Calculate target price based on risk-reward ratio."""
        pass
    
    def get_state(self, symbol: str, timeframe: str) -> StrategyState:
        """Get or create state for a symbol."""
        key = f"{symbol}:{timeframe}"
        if key not in self._states:
            self._states[key] = StrategyState(symbol=symbol, timeframe=timeframe)
        return self._states[key]
    
    def update_state(
        self,
        symbol: str,
        timeframe: str,
        **kwargs
    ) -> None:
        """Update state for a symbol."""
        state = self.get_state(symbol, timeframe)
        for key, value in kwargs.items():
            if hasattr(state, key):
                setattr(state, key, value)
    
    def is_trading_hours(self, current_time: Optional[datetime] = None) -> bool:
        """Check if within trading hours."""
        if current_time is None:
            current_time = datetime.now(ZoneInfo("Asia/Kolkata"))
        current = current_time.time()
        return self.market_open <= current <= self.market_close
    
    def can_enter_new_position(self, current_time: Optional[datetime] = None) -> bool:
        """Check if new entries are allowed at current time."""
        if current_time is None:
            current_time = datetime.now(ZoneInfo("Asia/Kolkata"))
        current = current_time.time()
        return self.market_open <= current <= self.no_new_entry_after
    
    def generate_signal_id(self) -> str:
        """Generate unique signal ID."""
        import uuid
        return f"SIG-{self.strategy_id}-{uuid.uuid4().hex[:8]}"


class VolumeRocketStrategy(BaseStrategy):
    """
    Volume Rocket Strategy Implementation.
    
    Entry Conditions:
    - Price crosses above VWMA(22)
    - Supertrend is bullish (price above supertrend)
    - Volume confirmation (current volume > avg volume * multiplier)
    - RSI between 40-70 (not overbought/oversold)
    
    Exit Conditions:
    - Price closes below VWMA(31) OR
    - Stop loss hit (ATR-based or swing low) OR
    - Target hit (R:R based)
    
    This is for OPTIONS BUYING (calls for long, puts for short).
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        default_config = {
            "vwma_fast": 22,
            "vwma_slow": 31,
            "supertrend_period": 10,
            "supertrend_multiplier": 3,
            "atr_period": 14,
            "atr_sl_multiplier": 1.5,
            "rsi_period": 14,
            "rsi_min": 40,
            "rsi_max": 70,
            "volume_multiplier": 1.5,
            "risk_reward_ratio": 2.0,
            "quantity_pct": 5.0,  # 5% of capital per trade
            "signal_validity_minutes": 5,
            "timeframes": ["5m"],  # Primary timeframe
            "instruments": ["NIFTY", "BANKNIFTY"],  # Index options
        }
        if config:
            default_config.update(config)
            
        super().__init__(
            strategy_id="VOLROCKET",
            name="Volume Rocket",
            description="Momentum strategy using VWMA crossover with Supertrend confirmation",
            config=default_config
        )
    
    async def evaluate(
        self,
        symbol: str,
        timeframe: str,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Optional[Signal]:
        """Evaluate Volume Rocket strategy conditions."""
        
        # Check if strategy applies to this timeframe
        if timeframe not in self.config["timeframes"]:
            return None
        
        # Check trading hours
        if not self.can_enter_new_position():
            return None
        
        state = self.get_state(symbol, timeframe)
        
        # Extract required indicators
        vwma_fast = indicators.get(f"vwma_{self.config['vwma_fast']}")
        vwma_slow = indicators.get(f"vwma_{self.config['vwma_slow']}")
        supertrend = indicators.get("supertrend")
        supertrend_direction = indicators.get("supertrend_direction")
        atr = indicators.get(f"atr_{self.config['atr_period']}")
        rsi = indicators.get(f"rsi_{self.config['rsi_period']}")
        volume_ratio = indicators.get("volume_ratio", 1.0)
        
        # Validate all required indicators are present
        if None in [vwma_fast, vwma_slow, supertrend, atr, rsi]:
            self.logger.debug(f"Missing indicators for {symbol}")
            return None
        
        close = Decimal(str(candle.get("close", 0)))
        
        # --- LONG ENTRY CONDITIONS ---
        long_conditions = [
            close > Decimal(str(vwma_fast)),  # Price above fast VWMA
            supertrend_direction == 1,  # Bullish supertrend
            Decimal(str(self.config["rsi_min"])) <= Decimal(str(rsi)) <= Decimal(str(self.config["rsi_max"])),
            volume_ratio >= self.config["volume_multiplier"],  # Volume confirmation
        ]
        
        # --- SHORT ENTRY CONDITIONS ---
        short_conditions = [
            close < Decimal(str(vwma_fast)),  # Price below fast VWMA
            supertrend_direction == -1,  # Bearish supertrend
            Decimal(str(self.config["rsi_min"])) <= Decimal(str(rsi)) <= Decimal(str(self.config["rsi_max"])),
            volume_ratio >= self.config["volume_multiplier"],
        ]
        
        signal = None
        
        if all(long_conditions) and not state.is_in_position:
            signal_type = SignalType.LONG_ENTRY
            stop_loss = self.get_stop_loss(close, signal_type, indicators, candle)
            target = self.get_target(close, stop_loss, signal_type, indicators)
            
            signal = Signal(
                signal_id=self.generate_signal_id(),
                strategy_id=self.strategy_id,
                strategy_name=self.name,
                symbol=symbol,
                exchange=symbol.split(":")[0] if ":" in symbol else "NSE",
                signal_type=signal_type,
                strength=self._calculate_signal_strength(indicators),
                entry_price=close,
                stop_loss=stop_loss,
                target_price=target,
                quantity_pct=self.config["quantity_pct"],
                timeframe=timeframe,
                indicators={
                    "vwma_fast": float(vwma_fast),
                    "vwma_slow": float(vwma_slow),
                    "supertrend": float(supertrend),
                    "atr": float(atr),
                    "rsi": float(rsi),
                    "volume_ratio": float(volume_ratio),
                },
                reason=self._generate_reason(signal_type, indicators),
                generated_at=datetime.now(ZoneInfo("Asia/Kolkata")),
                valid_until=datetime.now(ZoneInfo("Asia/Kolkata")) + 
                           asyncio.timedelta(minutes=self.config["signal_validity_minutes"]),
                metadata={"candle": candle}
            )
            
        elif all(short_conditions) and not state.is_in_position:
            signal_type = SignalType.SHORT_ENTRY
            stop_loss = self.get_stop_loss(close, signal_type, indicators, candle)
            target = self.get_target(close, stop_loss, signal_type, indicators)
            
            signal = Signal(
                signal_id=self.generate_signal_id(),
                strategy_id=self.strategy_id,
                strategy_name=self.name,
                symbol=symbol,
                exchange=symbol.split(":")[0] if ":" in symbol else "NSE",
                signal_type=signal_type,
                strength=self._calculate_signal_strength(indicators),
                entry_price=close,
                stop_loss=stop_loss,
                target_price=target,
                quantity_pct=self.config["quantity_pct"],
                timeframe=timeframe,
                indicators={
                    "vwma_fast": float(vwma_fast),
                    "vwma_slow": float(vwma_slow),
                    "supertrend": float(supertrend),
                    "atr": float(atr),
                    "rsi": float(rsi),
                    "volume_ratio": float(volume_ratio),
                },
                reason=self._generate_reason(signal_type, indicators),
                generated_at=datetime.now(ZoneInfo("Asia/Kolkata")),
                valid_until=datetime.now(ZoneInfo("Asia/Kolkata")) + 
                           asyncio.timedelta(minutes=self.config["signal_validity_minutes"]),
                metadata={"candle": candle}
            )
        
        # Check exit conditions if in position
        if state.is_in_position:
            exit_signal = await self._check_exit_conditions(
                symbol, timeframe, indicators, candle, state
            )
            if exit_signal:
                return exit_signal
        
        return signal
    
    async def _check_exit_conditions(
        self,
        symbol: str,
        timeframe: str,
        indicators: Dict[str, Any],
        candle: Dict[str, Any],
        state: StrategyState
    ) -> Optional[Signal]:
        """Check if exit conditions are met for existing position."""
        
        vwma_slow = indicators.get(f"vwma_{self.config['vwma_slow']}")
        close = Decimal(str(candle.get("close", 0)))
        
        if state.last_signal_type == SignalType.LONG_ENTRY:
            # Exit long if price closes below slow VWMA
            if vwma_slow and close < Decimal(str(vwma_slow)):
                return Signal(
                    signal_id=self.generate_signal_id(),
                    strategy_id=self.strategy_id,
                    strategy_name=self.name,
                    symbol=symbol,
                    exchange=symbol.split(":")[0] if ":" in symbol else "NSE",
                    signal_type=SignalType.LONG_EXIT,
                    strength=SignalStrength.STRONG,
                    entry_price=close,
                    stop_loss=Decimal("0"),
                    target_price=Decimal("0"),
                    quantity_pct=100.0,  # Exit full position
                    timeframe=timeframe,
                    indicators={"vwma_slow": float(vwma_slow)},
                    reason=f"Price {close} closed below VWMA({self.config['vwma_slow']}) at {vwma_slow:.2f}",
                    generated_at=datetime.now(ZoneInfo("Asia/Kolkata")),
                    valid_until=datetime.now(ZoneInfo("Asia/Kolkata")) + 
                               asyncio.timedelta(minutes=1),
                )
        
        elif state.last_signal_type == SignalType.SHORT_ENTRY:
            # Exit short if price closes above slow VWMA
            if vwma_slow and close > Decimal(str(vwma_slow)):
                return Signal(
                    signal_id=self.generate_signal_id(),
                    strategy_id=self.strategy_id,
                    strategy_name=self.name,
                    symbol=symbol,
                    exchange=symbol.split(":")[0] if ":" in symbol else "NSE",
                    signal_type=SignalType.SHORT_EXIT,
                    strength=SignalStrength.STRONG,
                    entry_price=close,
                    stop_loss=Decimal("0"),
                    target_price=Decimal("0"),
                    quantity_pct=100.0,
                    timeframe=timeframe,
                    indicators={"vwma_slow": float(vwma_slow)},
                    reason=f"Price {close} closed above VWMA({self.config['vwma_slow']}) at {vwma_slow:.2f}",
                    generated_at=datetime.now(ZoneInfo("Asia/Kolkata")),
                    valid_until=datetime.now(ZoneInfo("Asia/Kolkata")) + 
                               asyncio.timedelta(minutes=1),
                )
        
        return None
    
    def get_stop_loss(
        self,
        entry_price: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Decimal:
        """Calculate ATR-based stop loss."""
        atr = Decimal(str(indicators.get(f"atr_{self.config['atr_period']}", 0)))
        multiplier = Decimal(str(self.config["atr_sl_multiplier"]))
        
        if signal_type in [SignalType.LONG_ENTRY]:
            # Stop loss below entry for long
            sl = entry_price - (atr * multiplier)
            # Also consider candle low
            candle_low = Decimal(str(candle.get("low", entry_price)))
            sl = min(sl, candle_low - atr * Decimal("0.5"))
        else:
            # Stop loss above entry for short
            sl = entry_price + (atr * multiplier)
            candle_high = Decimal(str(candle.get("high", entry_price)))
            sl = max(sl, candle_high + atr * Decimal("0.5"))
        
        return sl.quantize(Decimal("0.05"))  # Round to tick size
    
    def get_target(
        self,
        entry_price: Decimal,
        stop_loss: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any]
    ) -> Decimal:
        """Calculate target based on risk-reward ratio."""
        risk = abs(entry_price - stop_loss)
        rr_ratio = Decimal(str(self.config["risk_reward_ratio"]))
        
        if signal_type in [SignalType.LONG_ENTRY]:
            target = entry_price + (risk * rr_ratio)
        else:
            target = entry_price - (risk * rr_ratio)
        
        return target.quantize(Decimal("0.05"))
    
    def _calculate_signal_strength(self, indicators: Dict[str, Any]) -> SignalStrength:
        """Calculate signal strength based on indicator alignment."""
        score = 0
        
        # Volume confirmation strength
        volume_ratio = indicators.get("volume_ratio", 1.0)
        if volume_ratio >= 2.0:
            score += 2
        elif volume_ratio >= 1.5:
            score += 1
        
        # RSI position (middle is better for momentum)
        rsi = indicators.get(f"rsi_{self.config['rsi_period']}", 50)
        if 45 <= rsi <= 55:
            score += 2
        elif 40 <= rsi <= 60:
            score += 1
        
        # Supertrend strength
        supertrend_direction = indicators.get("supertrend_direction", 0)
        if supertrend_direction != 0:
            score += 1
        
        if score >= 4:
            return SignalStrength.STRONG
        elif score >= 2:
            return SignalStrength.MODERATE
        return SignalStrength.WEAK
    
    def _generate_reason(self, signal_type: SignalType, indicators: Dict[str, Any]) -> str:
        """Generate human-readable reason for the signal."""
        direction = "LONG" if signal_type == SignalType.LONG_ENTRY else "SHORT"
        vwma = indicators.get(f"vwma_{self.config['vwma_fast']}", 0)
        st_dir = "bullish" if indicators.get("supertrend_direction") == 1 else "bearish"
        vol = indicators.get("volume_ratio", 1.0)
        rsi = indicators.get(f"rsi_{self.config['rsi_period']}", 50)
        
        return (
            f"{direction}: Price crossed VWMA({self.config['vwma_fast']}) at {vwma:.2f}, "
            f"Supertrend {st_dir}, Volume {vol:.1f}x avg, RSI {rsi:.1f}"
        )


class MorningMomentumAlphaStrategy(BaseStrategy):
    """
    Morning Momentum Alpha Strategy Implementation.
    
    Validated strategy with 81.6% win rate across 473 trades (Oct-Dec 2025).
    
    Entry Conditions:
    - Time window: 9:25-9:35 AM IST
    - Stock opens within 2% of ATM strike
    - Early momentum > 0.5% in first 15 minutes
    - Option has non-zero volume
    - Enter ATM CE for bullish, ATM PE for bearish momentum
    
    Exit Conditions:
    - Target: 50% profit on option premium
    - Stop Loss: 40% loss on option premium
    - Time Stop: 2:30 PM IST
    
    This strategy trades OPTIONS directly (CE for long, PE for short).
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        default_config = {
            # Entry conditions
            "min_momentum_pct": 0.5,       # Minimum early momentum %
            "max_atm_distance_pct": 2.0,   # Max distance from ATM strike %
            "entry_window_start": time(9, 25),
            "entry_window_end": time(9, 35),
            
            # Exit conditions
            "target_pct": 50.0,            # 50% profit target on premium
            "stoploss_pct": 40.0,          # 40% stop loss on premium
            "time_exit": time(14, 30),     # 2:30 PM time stop
            
            # Position sizing
            "quantity_pct": 5.0,           # 5% of capital per trade
            "max_positions": 3,            # Maximum simultaneous positions
            
            # Valid timeframes and instruments
            "timeframes": ["1m", "5m"],    # Monitor 1m and 5m for momentum
            "instruments": [],             # Empty = all F&O stocks
            
            # Signal settings
            "signal_validity_minutes": 10,
        }
        if config:
            default_config.update(config)
            
        super().__init__(
            strategy_id="MMALPHA",
            name="Morning Momentum Alpha",
            description="ATM options strategy based on first 15-minute momentum (81.6% win rate)",
            config=default_config
        )
        
        # Override trading hours for this strategy
        self.no_new_entry_after = default_config["entry_window_end"]
        
        # Track which symbols had signals today (one signal per day)
        self._signals_today: Set[str] = set()
        self._last_reset_date: Optional[datetime] = None
    
    def _reset_daily_state(self) -> None:
        """Reset daily state at market open."""
        now = datetime.now(ZoneInfo("Asia/Kolkata"))
        if self._last_reset_date is None or self._last_reset_date.date() != now.date():
            self._signals_today.clear()
            self._last_reset_date = now
            self.logger.info(f"Reset daily state for {self.name}")
    
    def _is_entry_window(self, current_time: Optional[datetime] = None) -> bool:
        """Check if within the 9:25-9:35 AM entry window."""
        if current_time is None:
            current_time = datetime.now(ZoneInfo("Asia/Kolkata"))
        current = current_time.time()
        return (self.config["entry_window_start"] <= current <= 
                self.config["entry_window_end"])
    
    async def evaluate(
        self,
        symbol: str,
        timeframe: str,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Optional[Signal]:
        """Evaluate Morning Momentum Alpha strategy conditions."""
        
        # Reset daily state if needed
        self._reset_daily_state()
        
        # Only check during entry window
        if not self._is_entry_window():
            return None
        
        # Check if we already generated a signal for this symbol today
        clean_symbol = symbol.split(":")[1] if ":" in symbol else symbol
        clean_symbol = clean_symbol.replace("-EQ", "")
        
        if clean_symbol in self._signals_today:
            return None
        
        state = self.get_state(symbol, timeframe)
        
        # Skip if already in position
        if state.is_in_position:
            return None
        
        # Get required data from candle
        open_price = Decimal(str(candle.get("open", 0)))
        close_price = Decimal(str(candle.get("close", 0)))
        
        if open_price == 0:
            return None
        
        # Calculate momentum
        momentum_pct = float((close_price - open_price) / open_price) * 100
        
        # Check minimum momentum threshold
        min_momentum = self.config["min_momentum_pct"]
        if abs(momentum_pct) < min_momentum:
            self.logger.debug(f"{symbol}: Low momentum {momentum_pct:.2f}%")
            return None
        
        # Determine signal type based on momentum direction
        if momentum_pct > 0:
            signal_type = SignalType.LONG_ENTRY
            option_type = "CE"
        else:
            signal_type = SignalType.SHORT_ENTRY
            option_type = "PE"
        
        # Calculate ATM strike
        current_price = float(close_price)
        if current_price < 500:
            strike_step = 10
        elif current_price < 1000:
            strike_step = 50
        elif current_price < 5000:
            strike_step = 100
        else:
            strike_step = 500
        
        atm_strike = round(current_price / strike_step) * strike_step
        
        # Check ATM distance
        distance_to_atm_pct = abs((current_price - atm_strike) / atm_strike) * 100
        if distance_to_atm_pct > self.config["max_atm_distance_pct"]:
            self.logger.debug(f"{symbol}: Too far from ATM {distance_to_atm_pct:.2f}%")
            return None
        
        # Calculate stop loss and target based on premium-based exits
        # For options, SL and target are % of entry premium
        # Entry price here represents the expected premium (we use spot for reference)
        entry_price = close_price
        
        # SL/Target are calculated as % of premium, stored in metadata
        stop_loss = self.get_stop_loss(entry_price, signal_type, indicators, candle)
        target = self.get_target(entry_price, stop_loss, signal_type, indicators)
        
        # Signal strength based on momentum magnitude
        strength = self._calculate_signal_strength(momentum_pct, indicators)
        
        # Mark this symbol as having a signal today
        self._signals_today.add(clean_symbol)
        
        self.logger.info(
            f"SIGNAL: {clean_symbol} {option_type} | Momentum: {momentum_pct:+.2f}% | "
            f"ATM: {atm_strike} | Distance: {distance_to_atm_pct:.2f}%"
        )
        
        return Signal(
            signal_id=self.generate_signal_id(),
            strategy_id=self.strategy_id,
            strategy_name=self.name,
            symbol=symbol,
            exchange=symbol.split(":")[0] if ":" in symbol else "NSE",
            signal_type=signal_type,
            strength=strength,
            entry_price=close_price,
            stop_loss=stop_loss,
            target_price=target,
            quantity_pct=self.config["quantity_pct"],
            timeframe=timeframe,
            indicators={
                "momentum_pct": momentum_pct,
                "atm_strike": atm_strike,
                "option_type": option_type,
                "distance_to_atm_pct": distance_to_atm_pct,
            },
            reason=self._generate_reason(signal_type, momentum_pct, atm_strike, option_type),
            generated_at=datetime.now(ZoneInfo("Asia/Kolkata")),
            valid_until=datetime.now(ZoneInfo("Asia/Kolkata")) + 
                       timedelta(minutes=self.config["signal_validity_minutes"]),
            metadata={
                "candle": candle,
                "option_type": option_type,
                "atm_strike": atm_strike,
                "target_pct": self.config["target_pct"],
                "stoploss_pct": self.config["stoploss_pct"],
                "time_exit": str(self.config["time_exit"]),
            }
        )
    
    def get_stop_loss(
        self,
        entry_price: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any],
        candle: Dict[str, Any]
    ) -> Decimal:
        """Calculate stop loss based on 40% premium loss."""
        # For options premium-based strategy, SL is 40% below entry
        sl_pct = Decimal(str(self.config["stoploss_pct"])) / 100
        
        # SL price represents premium after 40% loss
        return (entry_price * (1 - sl_pct)).quantize(Decimal("0.05"))
    
    def get_target(
        self,
        entry_price: Decimal,
        stop_loss: Decimal,
        signal_type: SignalType,
        indicators: Dict[str, Any]
    ) -> Decimal:
        """Calculate target based on 50% premium profit."""
        # For options premium-based strategy, target is 50% above entry
        target_pct = Decimal(str(self.config["target_pct"])) / 100
        
        # Target price represents premium after 50% gain
        return (entry_price * (1 + target_pct)).quantize(Decimal("0.05"))
    
    def _calculate_signal_strength(
        self, 
        momentum_pct: float,
        indicators: Dict[str, Any]
    ) -> SignalStrength:
        """Calculate signal strength based on momentum magnitude."""
        abs_momentum = abs(momentum_pct)
        
        if abs_momentum >= 1.0:
            return SignalStrength.STRONG
        elif abs_momentum >= 0.7:
            return SignalStrength.MODERATE
        else:
            return SignalStrength.WEAK
    
    def _generate_reason(
        self, 
        signal_type: SignalType, 
        momentum_pct: float,
        atm_strike: int,
        option_type: str
    ) -> str:
        """Generate human-readable reason for the signal."""
        direction = "LONG" if signal_type == SignalType.LONG_ENTRY else "SHORT"
        
        return (
            f"{direction}: Morning momentum {momentum_pct:+.2f}% → "
            f"BUY {atm_strike} {option_type} | "
            f"Target: 50% profit | SL: 40% loss | Time Exit: 2:30 PM"
        )


class StrategyRegistry:
    """Registry for managing strategy instances."""
    
    def __init__(self):
        self._strategies: Dict[str, BaseStrategy] = {}
        self._strategy_classes: Dict[str, Type[BaseStrategy]] = {}
        self.logger = logging.getLogger(__name__)
    
    def register_class(self, strategy_id: str, strategy_class: Type[BaseStrategy]) -> None:
        """Register a strategy class for dynamic instantiation."""
        self._strategy_classes[strategy_id] = strategy_class
        self.logger.info(f"Registered strategy class: {strategy_id}")
    
    def create_strategy(
        self,
        strategy_id: str,
        config: Optional[Dict[str, Any]] = None
    ) -> BaseStrategy:
        """Create and register a strategy instance."""
        if strategy_id not in self._strategy_classes:
            raise ValueError(f"Unknown strategy: {strategy_id}")
        
        strategy = self._strategy_classes[strategy_id](config)
        self._strategies[strategy.strategy_id] = strategy
        self.logger.info(f"Created strategy instance: {strategy.name}")
        return strategy
    
    def get_strategy(self, strategy_id: str) -> Optional[BaseStrategy]:
        """Get a registered strategy instance."""
        return self._strategies.get(strategy_id)
    
    def get_all_strategies(self) -> List[BaseStrategy]:
        """Get all registered strategy instances."""
        return list(self._strategies.values())
    
    def get_enabled_strategies(self) -> List[BaseStrategy]:
        """Get all enabled strategies."""
        return [s for s in self._strategies.values() if s.enabled]
    
    def enable_strategy(self, strategy_id: str) -> bool:
        """Enable a strategy."""
        if strategy_id in self._strategies:
            self._strategies[strategy_id].enabled = True
            return True
        return False
    
    def disable_strategy(self, strategy_id: str) -> bool:
        """Disable a strategy."""
        if strategy_id in self._strategies:
            self._strategies[strategy_id].enabled = False
            return True
        return False
    
    def remove_strategy(self, strategy_id: str) -> bool:
        """Remove a strategy instance."""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            return True
        return False


class StrategyEngine:
    """
    Main strategy execution engine.
    
    Coordinates:
    - Strategy evaluation on incoming indicator events
    - Signal generation and publishing
    - Strategy lifecycle management
    - Performance tracking per strategy
    """
    
    def __init__(
        self,
        event_bus: EventBus,
        registry: Optional[StrategyRegistry] = None
    ):
        self.event_bus = event_bus
        self.registry = registry or StrategyRegistry()
        self.logger = logging.getLogger(__name__)
        self._running = False
        self._task: Optional[asyncio.Task] = None
        
        # Performance tracking
        self._signal_count: Dict[str, int] = {}
        self._evaluation_count: int = 0
        
        # Register built-in strategies
        self._register_builtin_strategies()
    
    def _register_builtin_strategies(self) -> None:
        """Register built-in strategy classes."""
        self.registry.register_class("VOLROCKET", VolumeRocketStrategy)
        self.registry.register_class("MMALPHA", MorningMomentumAlphaStrategy)
    
    async def start(self) -> None:
        """Start the strategy engine."""
        if self._running:
            self.logger.warning("Strategy engine already running")
            return
        
        self._running = True
        self.logger.info("Starting strategy engine...")
        
        # Subscribe to indicator events
        await self.event_bus.subscribe(
            EventType.INDICATOR_UPDATED,
            self._on_indicator_event,
        )
        
        self.logger.info("Strategy engine started")
    
    async def stop(self) -> None:
        """Stop the strategy engine."""
        self._running = False
        
        # Note: EventBus doesn't have unsubscribe - consumers stop when event bus is stopped
        
        if self._task and not self._task.done():
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        
        self.logger.info("Strategy engine stopped")
    
    async def _on_indicator_event(self, event: IndicatorEvent) -> None:
        """Handle incoming indicator events."""
        try:
            symbol = event.symbol
            timeframe = event.timeframe
            indicators = event.indicators
            candle = event.metadata.get("candle", {})
            
            if not all([symbol, timeframe, indicators]):
                return
            
            self._evaluation_count += 1
            
            # Evaluate all enabled strategies
            for strategy in self.registry.get_enabled_strategies():
                try:
                    signal = await strategy.evaluate(
                        symbol=symbol,
                        timeframe=timeframe,
                        indicators=indicators,
                        candle=candle
                    )
                    
                    if signal:
                        await self._publish_signal(signal)
                        
                        # Track signal count
                        self._signal_count[strategy.strategy_id] = \
                            self._signal_count.get(strategy.strategy_id, 0) + 1
                        
                        self.logger.info(
                            f"Signal generated: {signal.signal_type.value} "
                            f"for {signal.symbol} by {signal.strategy_name}"
                        )
                        
                except Exception as e:
                    self.logger.error(
                        f"Error evaluating strategy {strategy.name} "
                        f"for {symbol}: {e}"
                    )
                    
        except Exception as e:
            self.logger.error(f"Error processing indicator event: {e}")
    
    async def _publish_signal(self, signal: Signal) -> None:
        """Publish signal to event bus."""
        from dataclasses import asdict
        
        signal_data = asdict(signal)
        # Convert Decimal to float and datetime to ISO string
        signal_data["entry_price"] = float(signal.entry_price)
        signal_data["stop_loss"] = float(signal.stop_loss)
        signal_data["target_price"] = float(signal.target_price)
        signal_data["generated_at"] = signal.generated_at.isoformat()
        signal_data["valid_until"] = signal.valid_until.isoformat()
        signal_data["signal_type"] = signal.signal_type.value
        signal_data["strength"] = signal.strength.value
        
        await self.event_bus.publish("signal", signal_data)
    
    def initialize_strategy(
        self,
        strategy_id: str,
        config: Optional[Dict[str, Any]] = None
    ) -> BaseStrategy:
        """Initialize a strategy with given configuration."""
        return self.registry.create_strategy(strategy_id, config)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get engine statistics."""
        return {
            "running": self._running,
            "evaluation_count": self._evaluation_count,
            "signal_counts": self._signal_count.copy(),
            "strategies": {
                s.strategy_id: {
                    "name": s.name,
                    "enabled": s.enabled,
                    "signals": self._signal_count.get(s.strategy_id, 0)
                }
                for s in self.registry.get_all_strategies()
            }
        }
    
    async def backtest_signal(
        self,
        strategy_id: str,
        symbol: str,
        timeframe: str,
        historical_data: List[Dict[str, Any]]
    ) -> List[Signal]:
        """
        Run strategy against historical data for backtesting.
        
        Args:
            strategy_id: Strategy to backtest
            symbol: Symbol to backtest
            timeframe: Timeframe of data
            historical_data: List of candle data with indicators
            
        Returns:
            List of signals generated
        """
        strategy = self.registry.get_strategy(strategy_id)
        if not strategy:
            raise ValueError(f"Strategy not found: {strategy_id}")
        
        signals = []
        for data in historical_data:
            signal = await strategy.evaluate(
                symbol=symbol,
                timeframe=timeframe,
                indicators=data.get("indicators", {}),
                candle=data.get("candle", {})
            )
            if signal:
                signals.append(signal)
        
        return signals


# Factory function for dependency injection
def create_strategy_engine(event_bus: EventBus) -> StrategyEngine:
    """Create and configure strategy engine instance."""
    engine = StrategyEngine(event_bus)
    
    # Initialize default strategies
    engine.initialize_strategy("VOLROCKET")
    engine.initialize_strategy("MMALPHA")  # Morning Momentum Alpha (81.6% win rate)
    
    return engine
