#!/usr/bin/env python3
"""
Morning Momentum Alpha - Signal Scanner

Scans F&O stocks for entry signals based on the Morning Momentum Alpha strategy.
This is a read-only scanner - it shows signals but does NOT execute trades.

Usage:
    python morning_momentum_scanner.py
    python morning_momentum_scanner.py --stocks RELIANCE,TCS,INFY
    python morning_momentum_scanner.py --date 2024-12-10  # Backtest mode
"""

import asyncio
import asyncpg
import argparse
from datetime import datetime, date, time as dt_time, timedelta
from typing import List, Dict, Optional
from dataclasses import dataclass
import logging

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

DB_URL = 'postgresql://user:password@127.0.0.1:5432/keepgaining'


@dataclass
class Signal:
    """A trading signal generated by the scanner."""
    stock: str
    option_type: str  # CE or PE
    strike: int
    entry_premium: float
    spot_open: float
    spot_current: float
    momentum_pct: float
    distance_to_atm_pct: float
    signal_time: datetime
    
    def __str__(self):
        direction = "ðŸŸ¢ BULLISH" if self.option_type == "CE" else "ðŸ”´ BEARISH"
        return (
            f"{direction} | {self.stock} {self.strike} {self.option_type}\n"
            f"   Momentum: {self.momentum_pct:+.2f}% | ATM Distance: {self.distance_to_atm_pct:.2f}%\n"
            f"   Spot: {self.spot_open:.2f} â†’ {self.spot_current:.2f}\n"
            f"   Premium: â‚¹{self.entry_premium:.2f}"
        )


class MorningMomentumScanner:
    """Scanner for Morning Momentum Alpha signals."""
    
    # Strategy parameters
    MIN_MOMENTUM_PCT = 0.5  # Minimum early momentum
    MAX_ATM_DISTANCE_PCT = 2.0  # Max distance from ATM
    ENTRY_WINDOW_START = dt_time(9, 25)
    ENTRY_WINDOW_END = dt_time(9, 40)
    
    def __init__(self, db_url: str = DB_URL):
        self.db_url = db_url
        self.pool = None
        
    async def connect(self):
        """Connect to database."""
        self.pool = await asyncpg.create_pool(self.db_url)
        logger.info("Connected to database")
        
    async def close(self):
        """Close database connection."""
        if self.pool:
            await self.pool.close()
    
    async def get_fno_stocks(self, limit: int = 50) -> List[str]:
        """Get list of F&O stocks."""
        async with self.pool.acquire() as conn:
            # Get stocks that have both equity and option data
            rows = await conn.fetch("""
                SELECT DISTINCT im.trading_symbol
                FROM instrument_master im
                WHERE im.instrument_type = 'EQUITY'
                  AND im.segment = 'EQ'
                  AND EXISTS (
                      SELECT 1 FROM option_master om
                      JOIN instrument_master im2 ON om.instrument_id = im2.instrument_id
                      WHERE im2.underlying = im.trading_symbol
                  )
                ORDER BY im.trading_symbol
                LIMIT $1
            """, limit)
            if rows:
                return [row['trading_symbol'] for row in rows]
            
            # Fallback to hardcoded list
            return ['RELIANCE', 'TCS', 'INFY', 'HDFCBANK', 'ICICIBANK', 'SBIN',
                    'BAJFINANCE', 'AXISBANK', 'TATAMOTORS', 'MARUTI', 'WIPRO',
                    'HCLTECH', 'ITC', 'BHARTIARTL', 'KOTAKBANK', 'LT', 'ASIANPAINT',
                    'TITAN', 'ULTRACEMCO', 'SUNPHARMA']
    
    async def get_spot_prices(self, stock: str, target_date: date) -> Dict[str, float]:
        """Get opening and current spot prices for a stock on given date."""
        async with self.pool.acquire() as conn:
            # Get first candle (open) and latest candle (close) for the entry window
            rows = await conn.fetch("""
                SELECT c.timestamp, c.open, c.close
                FROM candle_data c
                JOIN instrument_master im ON c.instrument_id = im.instrument_id
                WHERE im.trading_symbol = $1 
                  AND im.instrument_type = 'EQUITY'
                  AND DATE(c.timestamp) = $2
                  AND c.timestamp::time >= '03:45:00'  -- 9:15 IST in UTC
                  AND c.timestamp::time <= '04:10:00'  -- 9:40 IST in UTC
                ORDER BY c.timestamp
            """, stock, target_date)
            
            if not rows:
                return {}
            
            spot_open = float(rows[0]['open'])
            spot_current = float(rows[-1]['close'])
            
            return {
                'open': spot_open,
                'current': spot_current,
                'momentum_pct': ((spot_current - spot_open) / spot_open) * 100
            }
    
    async def get_atm_option(self, stock: str, spot_price: float, option_type: str, target_date: date) -> Optional[Dict]:
        """Find ATM option and get its premium."""
        # Calculate ATM strike
        if spot_price < 500:
            strike_step = 10
        elif spot_price < 1000:
            strike_step = 50
        elif spot_price < 5000:
            strike_step = 100
        else:
            strike_step = 500
            
        atm_strike = round(spot_price / strike_step) * strike_step
        
        async with self.pool.acquire() as conn:
            # Find option with this strike and get its premium
            row = await conn.fetchrow("""
                SELECT im.trading_symbol, c.close as premium, c.volume
                FROM candle_data c
                JOIN instrument_master im ON c.instrument_id = im.instrument_id
                JOIN option_master om ON im.instrument_id = om.instrument_id
                WHERE im.underlying = $1 
                  AND im.instrument_type = $2
                  AND om.strike_price = $3
                  AND om.expiry_date >= $4
                  AND DATE(c.timestamp) = $4
                  AND c.timestamp::time >= '04:00:00'  -- 9:30 IST in UTC
                  AND c.timestamp::time <= '04:10:00'  -- 9:40 IST in UTC
                ORDER BY om.expiry_date, c.timestamp DESC
                LIMIT 1
            """, stock, option_type, atm_strike, target_date)
            
            if row and float(row['premium']) > 0:
                return {
                    'symbol': row['trading_symbol'],
                    'strike': atm_strike,
                    'premium': float(row['premium']),
                    'volume': int(row['volume']) if row['volume'] else 0,
                    'distance_pct': abs((spot_price - atm_strike) / atm_strike) * 100
                }
            
            return None
    
    async def scan_stock(self, stock: str, target_date: date) -> Optional[Signal]:
        """Scan a single stock for signals."""
        try:
            # Get spot prices
            spot_data = await self.get_spot_prices(stock, target_date)
            if not spot_data:
                return None
            
            momentum_pct = spot_data['momentum_pct']
            
            # Check minimum momentum
            if abs(momentum_pct) < self.MIN_MOMENTUM_PCT:
                return None
            
            # Determine option type
            option_type = "CE" if momentum_pct > 0 else "PE"
            
            # Get ATM option
            option_data = await self.get_atm_option(
                stock, spot_data['current'], option_type, target_date
            )
            
            if not option_data:
                return None
            
            # Check ATM distance
            if option_data['distance_pct'] > self.MAX_ATM_DISTANCE_PCT:
                return None
            
            # Check volume
            if option_data['volume'] <= 0:
                return None
            
            # All conditions passed - create signal
            return Signal(
                stock=stock,
                option_type=option_type,
                strike=option_data['strike'],
                entry_premium=option_data['premium'],
                spot_open=spot_data['open'],
                spot_current=spot_data['current'],
                momentum_pct=momentum_pct,
                distance_to_atm_pct=option_data['distance_pct'],
                signal_time=datetime.combine(target_date, dt_time(9, 30))
            )
            
        except Exception as e:
            logger.debug(f"Error scanning {stock}: {e}")
            return None
    
    async def scan_all(self, stocks: List[str] = None, target_date: date = None) -> List[Signal]:
        """Scan all stocks and return signals."""
        if target_date is None:
            target_date = date.today()
        
        if stocks is None:
            stocks = await self.get_fno_stocks()
        
        logger.info(f"Scanning {len(stocks)} stocks for {target_date}...")
        
        signals = []
        for stock in stocks:
            signal = await self.scan_stock(stock, target_date)
            if signal:
                signals.append(signal)
        
        # Sort by momentum strength
        signals.sort(key=lambda s: abs(s.momentum_pct), reverse=True)
        
        return signals
    
    async def run_scanner(self, stocks: List[str] = None, target_date: date = None):
        """Run the scanner and display results."""
        await self.connect()
        
        try:
            signals = await self.scan_all(stocks, target_date)
            
            date_str = target_date.strftime("%Y-%m-%d") if target_date else "today"
            
            print("\n" + "=" * 60)
            print(f"  MORNING MOMENTUM ALPHA - SIGNALS FOR {date_str}")
            print("=" * 60)
            
            if not signals:
                print("\n  No signals found.")
            else:
                bullish = [s for s in signals if s.option_type == "CE"]
                bearish = [s for s in signals if s.option_type == "PE"]
                
                print(f"\n  Found {len(signals)} signals: {len(bullish)} Bullish, {len(bearish)} Bearish\n")
                
                for i, signal in enumerate(signals, 1):
                    print(f"  {i}. {signal}\n")
            
            print("=" * 60)
            print("  Strategy Rules:")
            print(f"    â€¢ Entry: 9:30 AM IST")
            print(f"    â€¢ Target: 50% profit on premium")
            print(f"    â€¢ Stop Loss: 40% loss on premium")
            print(f"    â€¢ Time Exit: 2:30 PM IST")
            print("=" * 60 + "\n")
            
            return signals
            
        finally:
            await self.close()


async def main():
    parser = argparse.ArgumentParser(description='Morning Momentum Alpha Scanner')
    parser.add_argument('--stocks', type=str, default=None,
                        help='Comma-separated stock symbols (e.g., RELIANCE,TCS)')
    parser.add_argument('--date', type=str, default=None,
                        help='Date to scan (YYYY-MM-DD). Default: today')
    parser.add_argument('--days', type=int, default=1,
                        help='Number of days to scan back from date')
    
    args = parser.parse_args()
    
    # Parse stocks
    stocks = None
    if args.stocks:
        stocks = [s.strip().upper() for s in args.stocks.split(',')]
    
    # Parse date
    target_date = None
    if args.date:
        target_date = datetime.strptime(args.date, '%Y-%m-%d').date()
    
    scanner = MorningMomentumScanner()
    
    if args.days > 1:
        # Multi-day scan
        base_date = target_date or date.today()
        all_signals = []
        
        for i in range(args.days):
            scan_date = base_date - timedelta(days=i)
            # Skip weekends
            if scan_date.weekday() >= 5:
                continue
            signals = await scanner.run_scanner(stocks, scan_date)
            all_signals.extend(signals)
        
        print(f"\nTotal signals across {args.days} days: {len(all_signals)}")
    else:
        # Single day scan
        await scanner.run_scanner(stocks, target_date)


if __name__ == "__main__":
    asyncio.run(main())
